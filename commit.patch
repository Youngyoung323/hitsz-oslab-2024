diff --git a/Makefile b/Makefile
index b971308..1f68a81 100644
--- a/Makefile
+++ b/Makefile
@@ -157,6 +157,9 @@ UPROGS=\
 	$U/_grind\
 	$U/_wc\
 	$U/_zombie\
+	$U/_sleep\
+	$U/_pingpong\
+	$U/_find\
 
 
 ifeq ($(LAB),syscall)
@@ -242,15 +245,8 @@ qemu-gdb: $K/kernel .gdbinit fs.img
 	@echo "*** Now run 'gdb' in another window." 1>&2
 	$(QEMU) $(QEMUOPTS) -S $(QEMUGDB)
 
-GDBARGS = 
-GDBARGS += -ex 'set architecture riscv:rv64'
-GDBARGS += -ex 'target remote 127.0.0.1:$(GDBPORT)'
-GDBARGS += -ex 'symbol-file kernel/kernel'
-GDBARGS += -ex 'set riscv use-compressed-breakpoints yes'
-
-
 gdb: 
-	$(GDB) $(GDBARGS)
+	$(GDB)
 
 ##
 ##  FOR testing lab grading script
diff --git a/commands.gdb b/commands.gdb
new file mode 100644
index 0000000..95238c2
--- /dev/null
+++ b/commands.gdb
@@ -0,0 +1,6 @@
+b trap.c:55
+c
+p cpus[$tp]->proc->name
+n
+p cpus[$tp]->proc->name
+da
\ No newline at end of file
diff --git a/user/find.c b/user/find.c
new file mode 100644
index 0000000..a684e59
--- /dev/null
+++ b/user/find.c
@@ -0,0 +1,72 @@
+#include "kernel/types.h"
+#include "kernel/stat.h"
+#include "kernel/fs.h"
+#include "user/user.h"
+
+void find(char *path, char *filename) {
+    int fd;            //打开文件的文件描述符 
+    struct stat st;    //文件状态信息
+    struct dirent de;  //文件条目，包含文件名以及inode
+
+    if ((fd = open(path, 0)) < 0) {         //文件无法打开
+        fprintf(2, "find: cannot open %s\n", path);
+        return;
+    }
+
+    if (fstat(fd, &st) < 0) {               //根据路径获取文件状态信息，如果获取失败
+        fprintf(2, "find: cannot stat %s\n", path);
+        close(fd);
+        return;
+    } 
+
+    if (st.type == T_FILE) {                //当前路径是文件直接返回s
+        fprintf(2, "find: %s not a directory\n", path);
+        return;
+    }
+
+    char buf[512];  //存放待输出的文件路径/目录路径，递归执行的基础
+    char *p;        //当前路径
+
+    if(strlen(path) + 1 + DIRSIZ + 1 > sizeof(buf)) {  //文件路径长度超过缓冲区最大长度
+        printf("find: path too long\n");    
+        return;
+    }
+
+    strcpy(buf, path);      //路径长度合理则将path的路径赋值给buf,递归基础
+    p = buf + strlen(buf);  //p得到buf路径并移动到路径末尾,buf和p共享的是一块区域，p改动会同步给buf
+    *p++ = '/';             //末尾加上文件分隔符
+
+    while(read(fd, &de, sizeof(de)) == sizeof(de)) {  //循环读取fd所代表目录下面每个条目的信息(就是读子文件和子目录)，并且保证每次读到都是一个完整的文件/目录项
+        if(de.inum == 0) continue;  //读到空项
+        if(strcmp(de.name, ".") == 0 || strcmp(de.name, "..") == 0) {  //避免递归当前目录和上级目录
+            continue;
+        } 
+        memmove(p, de.name, DIRSIZ); //将文件名追加到p的末尾
+        p[DIRSIZ] = 0;               //末尾添加字符串结束符
+
+        if (stat(buf, &st) < 0) {    //检查新路径下的文件信息是否可以被获取
+          fprintf(2, "find: cannot stat %s\n", buf);
+          continue;
+        }
+
+        if(st.type == T_FILE || st.type == T_DIR) {  //新的文件路径/目录路径与filename一致直接输出
+            if(strcmp(de.name, filename) == 0) {
+                printf("%s\n", buf);
+            }  
+        }
+
+        if(st.type == T_DIR) find(buf, filename);    //目录应该递归查询
+    }
+ }
+
+int main(int argc, char *argv[]) {
+    if(argc != 3) {
+        printf("Wrong command format! Should be find <path> <filename>\n");
+        exit(-1);
+    }
+
+    char *path = argv[1];      //路径
+    char *filename = argv[2];  //所寻文件名
+    find(path, filename);
+    exit(0);
+}
\ No newline at end of file
diff --git a/user/pingpong.c b/user/pingpong.c
new file mode 100644
index 0000000..3e0a330
--- /dev/null
+++ b/user/pingpong.c
@@ -0,0 +1,36 @@
+#include "kernel/types.h"
+#include "user/user.h"
+
+int main(int argc, char *argv[]) {
+    int p[2];              //管道端口
+    char receivedInfo[5];  //字符串接收缓冲区
+    int forkReturn;        //返回的子线程端口号
+    if (pipe(p) < 0) {
+        printf("pipe error!");
+    }
+
+    forkReturn = fork();  //fork系统调用返回值
+
+    if(forkReturn == 0) {
+        int parent_pid;
+        read(p[0], &parent_pid, sizeof(int));  //pid无论是几位数字都会占用固定大小的字节数
+        read(p[0], receivedInfo, 5);           //读取ping
+        close(p[0]);                
+        printf("%d: received %s from pid %d\n", getpid(), receivedInfo, parent_pid);
+        write(p[1], "pong", 5);                //写入pong
+        close(p[1]);
+        exit(0);                               //退出进程
+    } 
+    else if(forkReturn > 0) {
+        int parent_pid = getpid();
+        write(p[1], &parent_pid, sizeof(int)); //pid无论是几位数字都会占用固定大小的字节数
+        sleep(1);                              //等待子进程读完父进程的pid
+        write(p[1], "ping", 5);                //写入ping
+        close(p[1]);
+        sleep(1);                              //等待子进程读完
+        read(p[0], receivedInfo, 5);           //读取pong
+        printf("%d: received %s from pid %d\n", getpid(), receivedInfo, forkReturn);
+        close(p[0]);
+        exit(0);                               //退出进程
+    }
+}
\ No newline at end of file
diff --git a/user/sleep.c b/user/sleep.c
new file mode 100644
index 0000000..3d3e331
--- /dev/null
+++ b/user/sleep.c
@@ -0,0 +1,13 @@
+#include "kernel/types.h"
+#include "user.h"
+
+int main(int argc, char* argv[]) {
+    if(argc != 2) {
+        printf("Sleep needs one argument!\n");  //Check the number of argument 
+        exit(-1);
+    }
+    int ticks = atoi(argv[1]); //Convert strings to integers
+    sleep(ticks);              //The system call uses sleep
+    printf("(nothing happens for a little while)\n");
+    exit(0); //Ensure the process exit successfully
+}
\ No newline at end of file
